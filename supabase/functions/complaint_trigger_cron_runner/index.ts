// supabase/functions/complaint_trigger_cron_runner/index.ts
// Scheduled runner (cron) for complaint rewrite triggers.
//
// Flow (Pattern B):
// 1) claim queued jobs via complaint_trigger_pop_pending()
// 2) call orchestrator for each claimed job (HTTP)
// 3) if orchestrator call fails (network/timeout or non-2xx), requeue via complaint_trigger_mark_retry()
//
// Notes:
// - We pass trigger_request_id (claim ticket) so orchestrator can mark terminal states
//   using marker RPCs that enforce ownership.
// - p_retry_after in SQL is INTERVAL; we pass a safe literal like "00:10:00".
// - Runner is intended to be invoked by Supabase Scheduled Functions (cron).

import {
  createClient,
  type SupabaseClient,
} from "npm:@supabase/supabase-js@2.48.0";

type TriggerRow = {
  entry_id: string;
  home_id: string;
  author_user_id: string;
  recipient_user_id: string;
  request_id: string; // claim ticket generated by complaint_trigger_pop_pending()
};

type RpcLike = {
  rpc: (
    fn: string,
    args: Record<string, unknown>,
  ) => PromiseLike<{ data: unknown; error: { message: string } | null }>;
};

class ApiError extends Error {
  constructor(public status: number, message: string, public code?: string) {
    super(message);
  }
}

if (import.meta.main) {
  Deno.serve(async (req) => {
    // Optional: protect runner endpoint (recommended)
    // If RUNNER_SHARED_SECRET is set, caller must send x-internal-secret matching it.
    requireInternalSecret(req, "RUNNER_SHARED_SECRET");

    const supabase = supabaseServiceClient();

    const orchestratorUrl = env("ORCHESTRATOR_FUNCTION_URL");
    const orchestratorSecret = env("ORCHESTRATOR_SHARED_SECRET");

    const limit = clampInt(Deno.env.get("RUNNER_POP_LIMIT"), 1, 200, 20);
    const maxAttempts = clampInt(
      Deno.env.get("RUNNER_MAX_ATTEMPTS"),
      1,
      50,
      10,
    );
    const concurrency = clampInt(Deno.env.get("RUNNER_CONCURRENCY"), 1, 20, 5);

    const orchestratorTimeoutMs = clampInt(
      Deno.env.get("RUNNER_ORCHESTRATOR_TIMEOUT_MS"),
      1000,
      120_000,
      15_000,
    );

    // interval literal safe for postgres (INTERVAL)
    const retryAfter = Deno.env.get("RUNNER_RETRY_AFTER")?.trim() || "00:10:00";

    // 1) Claim queued jobs (atomic)
    const jobs = (await rpcJson<TriggerRow[]>(
      supabase,
      "complaint_trigger_pop_pending",
      { p_limit: limit, p_max_attempts: maxAttempts },
    )) ?? [];

    if (jobs.length === 0) {
      return json({ ok: true, claimed: 0 }, 200);
    }

    // 2) Process jobs with limited concurrency
    const results = await mapLimit(
      jobs,
      concurrency,
      (job) =>
        processClaimedJob({
          supabase,
          job,
          orchestratorUrl,
          orchestratorSecret,
          orchestratorTimeoutMs,
          retryAfter,
        }),
    );

    const okCount = results.filter((r) => r.ok).length;
    const failCount = results.length - okCount;

    return json(
      {
        ok: true,
        claimed: jobs.length,
        orchestrator_ok: okCount,
        orchestrator_failed: failCount,
        sample_failures: results.filter((r) => !r.ok).slice(0, 5),
      },
      200,
    );
  });
}

/* ---------------- HTTP helpers ---------------- */

async function postJsonWithTimeout(params: {
  url: string;
  secret: string;
  payload: unknown;
  timeoutMs: number;
}): Promise<{ ok: boolean; status: number; bodyText: string }> {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), params.timeoutMs);

  try {
    const resp = await fetch(params.url, {
      method: "POST",
      signal: controller.signal,
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        "x-internal-secret": params.secret,
      },
      body: JSON.stringify(params.payload),
    });

    const bodyText = await resp.text().catch(() => "");
    return { ok: resp.ok, status: resp.status, bodyText };
  } finally {
    clearTimeout(t);
  }
}

/* ---------------- Supabase + auth ---------------- */

function supabaseServiceClient(): SupabaseClient {
  const supabaseUrl = env("SUPABASE_URL");
  const serviceKey = env("SUPABASE_SERVICE_ROLE_KEY");
  return createClient(supabaseUrl, serviceKey, {
    auth: { autoRefreshToken: false, persistSession: false },
  });
}

function env(name: string): string {
  const v = Deno.env.get(name);
  if (!v) throw new ApiError(500, `Missing env ${name}`, "missing_env");
  return v;
}

function requireInternalSecret(req: Request, envName: string) {
  const expected = Deno.env.get(envName);
  if (!expected) return; // allow if you don't set it
  const got = req.headers.get("x-internal-secret");
  if (got !== expected) throw new ApiError(401, "unauthorized", "unauthorized");
}

/* ---------------- Response + RPC helpers ---------------- */

function json(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json; charset=utf-8" },
  });
}

async function rpcJson<T>(
  supabase: RpcLike,
  fn: string,
  args: Record<string, unknown>,
): Promise<T | null> {
  const { data, error } = await supabase.rpc(fn, args);
  if (error) {
    throw new ApiError(500, `${fn}_failed:${error.message}`, "rpc_failed");
  }
  return (data ?? null) as T | null;
}

// Best-effort (do not throw)
async function rpcSafe(
  supabase: RpcLike,
  fn: string,
  args: Record<string, unknown>,
) {
  try {
    const { error } = await supabase.rpc(fn, args);
    if (error) {
      // swallow
    }
  } catch {
    // swallow
  }
}

/* ---------------- small utils ---------------- */

function clampInt(v: unknown, min: number, max: number, fallback: number) {
  const n = typeof v === "number" ? v : Number(v);
  if (!Number.isFinite(n)) return fallback;
  const i = Math.trunc(n);
  return Math.max(min, Math.min(max, i));
}

function truncate(s: string, n: number) {
  return s.length <= n ? s : s.slice(0, n) + "â€¦";
}

function toErrorMessage(e: unknown): string {
  if (e instanceof Error) return e.message;
  return String(e);
}

async function processClaimedJob(params: {
  supabase: RpcLike;
  job: TriggerRow;
  orchestratorUrl: string;
  orchestratorSecret: string;
  orchestratorTimeoutMs: number;
  retryAfter: string;
  postJson?: typeof postJsonWithTimeout;
}): Promise<{ ok: boolean; entry_id: string; status: number }> {
  const payload = {
    entry_id: params.job.entry_id,
    home_id: params.job.home_id,
    sender_user_id: params.job.author_user_id,
    recipient_user_id: params.job.recipient_user_id,
    surface: "weekly_harmony",
    trigger_request_id: params.job.request_id,
  };

  const postJson = params.postJson ?? postJsonWithTimeout;

  try {
    const { ok, status, bodyText } = await postJson({
      url: params.orchestratorUrl,
      secret: params.orchestratorSecret,
      payload,
      timeoutMs: params.orchestratorTimeoutMs,
    });

    if (!ok) {
      await rpcSafe(params.supabase, "complaint_trigger_mark_retry", {
        p_entry_id: params.job.entry_id,
        p_request_id: params.job.request_id,
        p_error: `orchestrator_http_${status}:${truncate(bodyText, 240)}`.slice(
          0,
          512,
        ),
        p_retry_after: params.retryAfter,
        p_note: "runner_requeue_orchestrator_http_error",
      });
      return { ok: false, entry_id: params.job.entry_id, status };
    }

    return { ok: true, entry_id: params.job.entry_id, status: 200 };
  } catch (e) {
    await rpcSafe(params.supabase, "complaint_trigger_mark_retry", {
      p_entry_id: params.job.entry_id,
      p_request_id: params.job.request_id,
      p_error: `orchestrator_call_failed:${toErrorMessage(e)}`.slice(0, 512),
      p_retry_after: params.retryAfter,
      p_note: "runner_requeue_orchestrator_call_failed",
    });
    return { ok: false, entry_id: params.job.entry_id, status: 0 };
  }
}

// Simple concurrency-limited mapper
async function mapLimit<T, R>(
  items: T[],
  limit: number,
  fn: (item: T) => Promise<R>,
): Promise<R[]> {
  const out: R[] = new Array(items.length);
  let idx = 0;

  const workers = Array.from(
    { length: Math.min(limit, items.length) },
    async () => {
      while (true) {
        const i = idx++;
        if (i >= items.length) break;
        out[i] = await fn(items[i]);
      }
    },
  );

  await Promise.all(workers);
  return out;
}

// Test-only exports
export {
  ApiError,
  clampInt,
  env,
  mapLimit,
  postJsonWithTimeout,
  processClaimedJob,
  requireInternalSecret,
  rpcJson,
  toErrorMessage,
  truncate,
};
